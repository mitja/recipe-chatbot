"""create_initial_tables

Revision ID: 90ce7707cc28
Revises: 
Create Date: 2025-05-23 22:50:59.926590

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
# Import your custom Enum for gender if it's used in a way that Alembic needs to know its structure,
# though often for Enums, SQLAlchemy handles the DDL generation correctly without explicit import here.
# For safety, let's ensure it can be imported if needed by the migration context.
# from database.models import GenderEnum # May not be strictly necessary if sa.Enum handles it

# revision identifiers, used by Alembic.
revision: str = '90ce7707cc28'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('family',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('slug', sa.String(length=100), nullable=False),
        sa.PrimaryKeyConstraint('id')
        # Unique constraints for name and slug are often created via op.create_unique_constraint
        # or handled by index creation with unique=True.
        # SQLAlchemy model definition implies these, Alembic autogen usually picks them up.
    )
    op.create_index(op.f('ix_family_id'), 'family', ['id'], unique=False)
    op.create_index(op.f('ix_family_name'), 'family', ['name'], unique=True)
    op.create_index(op.f('ix_family_slug'), 'family', ['slug'], unique=True)

    op.create_table('family_member',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('family_id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('height_cm', sa.Integer(), nullable=True),
        sa.Column('weight_kg', sa.Float(), nullable=True),
        sa.Column('age_years', sa.Integer(), nullable=True),
        # The GenderEnum values are 'male', 'female', 'diverse', 'prefer_not_to_say'
        # Using explicit string values for the Enum constructor in the migration.
        sa.Column('gender', sa.Enum('MALE', 'FEMALE', 'DIVERSE', 'PREFER_NOT_TO_SAY', name='genderenum'), nullable=True),
        sa.Column('target_caloric_intake_kcal', sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(['family_id'], ['family.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_family_member_id'), 'family_member', ['id'], unique=False)

    op.create_table('shopping_list',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('family_id', sa.Integer(), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('items_json', sa.JSON(), nullable=True),
        sa.ForeignKeyConstraint(['family_id'], ['family.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_shopping_list_id'), 'shopping_list', ['id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_shopping_list_id'), table_name='shopping_list')
    op.drop_table('shopping_list')
    op.drop_index(op.f('ix_family_member_id'), table_name='family_member')
    op.drop_table('family_member')
    op.drop_index(op.f('ix_family_slug'), table_name='family')
    op.drop_index(op.f('ix_family_name'), table_name='family')
    op.drop_index(op.f('ix_family_id'), table_name='family')
    op.drop_table('family')
    
    # For SQLite, explicit dropping of the ENUM type is not usually needed as it's
    # often implemented with CHECK constraints. If this were PostgreSQL with a native ENUM,
    # you might need: op.execute("DROP TYPE IF EXISTS genderenum;")
    # For now, we assume the backend (SQLite) handles this gracefully.
    # ### end Alembic commands ###
